{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Defensive File Scanner","text":""},{"location":"#concept","title":"Concept","text":"<p>Scanner large files for excessive null bits. Malware is getting around computer security by not scanning large files, but bloating them out with 0 bytes. Find a way to predict the likelihood of a file being malware by the presence of these bytes without slowing down the pc.</p>"},{"location":"#approach","title":"Approach","text":"<ol> <li> Scan whole file.</li> <li> Test random lines of code with a good spread of the program.</li> <li> Determine the average sum of bits in a file for a given size.</li> <li> Calculate the sum of the file.</li> <li> Remove the null bits and check with virus total.</li> </ol>"},{"location":"#questions","title":"Questions","text":"<ul> <li>Do the SHASUM of bloated programs have some identifiable part?</li> <li>Can you read set parts of a program without reading the whole file?</li> <li>What is the quickest way to work out if it is shady?</li> <li>What is the ratio of <code>0x00</code> bytes that are not normal?</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ol> <li>Time taken to assess large files &lt;1ms.</li> <li>Scan does not detonate the program.</li> <li>True Positive &gt; 90%</li> <li>False positive &lt; 10%</li> </ol>"},{"location":"Reference/","title":"Reference","text":""},{"location":"Reference/#defensive_file_scannercreate_file","title":"defensive_file_scanner.create_file","text":"<p>Generate a test file with dummy bytes and optional bloat to simulate malware.</p>"},{"location":"Reference/#defensive_file_scanner.create_file.main","title":"<code>main(filepath, start=1000, bloat=1000, end=0)</code>","text":"<p>Write a file with random bits as the 'program' and optional bloat.</p> Source code in <code>defensive_file_scanner/create_file.py</code> <pre><code>@click.command()\n@click.option(\n\"-f\",\n\"--filepath\",\ntype=click.Path(path_type=Path),\ndefault=Path(\"./testing/file.out\"),\nhelp=\"Filepath to save the file. Default = './testing/file.out'\",\n)\n@click.option(\n\"-s\",\n\"--start\",\ndefault=1_000,\nhelp=\"Number of hex digits in the simulated program at the start of file.\",\n)\n@click.option(\n\"-b\",\n\"--bloat\",\ndefault=1_000,\nhelp=(  # fmt: off\n\"Number of bloat hex digits or '\\x00' (which would be 2) in the file.\"\n),  # fmt: on\n)\n@click.option(\n\"-e\",\n\"--end\",\ndefault=0,\nhelp=\"Number of hex digits in the simulated program at the end of file.\",\n)\ndef main(filepath: Path, start: int = 1_000, bloat: int = 1_000, end: int = 0):\n\"\"\"\n    Write a file with random bits as the 'program' and optional bloat.\n    \"\"\"\nlogger.info(f\"Creating file: {filepath.resolve()}\")\nwrite_file(filepath, start, bloat, end)\nsize_str: str\nif (size := os.stat(filepath).st_size) &lt; 1_000:\nsize_str = f\"{size:,.2f} B\"\nelif size &lt; (1_000 * 1024):\nsize_str = f\"{size / 1024:,.2f} KB\"\nelif size &lt; (1_000 * 1024**2):\nsize_str = f\"{size / 1024 ** 2:,.2f} MB\"\nelse:\nsize_str = f\"{size / 1024 ** 3:,.2f} GB\"\nlogger.info(f\"File created of size: {size_str}\")\nreturn 0\n</code></pre>"},{"location":"Reference/#defensive_file_scanner.create_file.random_bytes","title":"<code>random_bytes(length=1000)</code>","text":"<p>Generate random bytes in hex format.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>Length of random hex digits.</p> <code>1000</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>A byte string of hex digits of a given length.</p> Source code in <code>defensive_file_scanner/create_file.py</code> <pre><code>def random_bytes(length: int = 1000) -&gt; bytes:\n\"\"\"\n    Generate random bytes in hex format.\n    Args:\n        length (int): Length of random hex digits.\n    Returns:\n        bytes: A byte string of hex digits of a given length.\n    \"\"\"\nprogram = \"\".join(\nrepeat_function(\nrandom.choice,\nstring.hexdigits,\nrepeats=length,\n)\n)\nreturn b\"\".fromhex(program)\n</code></pre>"},{"location":"Reference/#defensive_file_scanner.create_file.repeat_function","title":"<code>repeat_function(func, *args, repeats=1000, **kwargs)</code>","text":"<p>Run a function n times with given argument and keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[...], ...]</code> <p>Function to run.</p> required <code>*args</code> <code>Any</code> <p>Positional arguments for the function.</p> <code>()</code> <code>repeats</code> <code>int</code> <p>Number of times to repeat the function call.</p> <code>1000</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments for the function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Generator</code> <code>Generator</code> <p>With for the function to be called n number of times.</p> <p>Yields:</p> Name Type Description <code>Any</code> <code>Generator</code> <p>Result from the function call.</p> Source code in <code>defensive_file_scanner/create_file.py</code> <pre><code>def repeat_function(\nfunc: Callable[..., Any],\n*args: Any,\nrepeats: int = 1_000,\n**kwargs: Any,\n) -&gt; Generator:\n\"\"\"\n    Run a function n times with given argument and keyword arguments.\n    Args:\n        func (Callable[[...], ...]): Function to run.\n        *args (Any): Positional arguments for the function.\n        repeats (int): Number of times to repeat the function call.\n        **kwargs (Any): Keyword arguments for the function.\n    Returns:\n        Generator: With for the function to be called n number of times.\n    Yields:\n        Any: Result from the function call.\n    \"\"\"\nfor _ in range(repeats):\nyield func(*args, **kwargs)\n</code></pre>"},{"location":"Reference/#defensive_file_scanner.create_file.write_file","title":"<code>write_file(path, program_start=100000, bloat=100000, program_end=0)</code>","text":"<p>Writes the hex code for a test file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>A file path for the file.</p> required <code>program_start</code> <code>int</code> <p>Length of the \"program\" code at start of file.</p> <code>100000</code> <code>bloat</code> <code>int</code> <p>Length of bloat or no operation bytes '\u0000' in the file.</p> <code>100000</code> <code>program_end</code> <code>int</code> <p>Length of the \"program\" code at end of file.</p> <code>0</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>defensive_file_scanner/create_file.py</code> <pre><code>def write_file(\npath: Path,\nprogram_start: int = 100_000,\nbloat: int = 100_000,\nprogram_end: int = 0,\n) -&gt; None:\n\"\"\"\n    Writes the hex code for a test file.\n    Args:\n        path (Path): A file path for the file.\n        program_start (int): Length of the \"program\" code at start of file.\n        bloat (int): Length of bloat or no operation bytes '\\x00' in the file.\n        program_end (int): Length of the \"program\" code at end of file.\n    Returns:\n        None\n    \"\"\"\nwith open(path, \"wb\") as f:\nprogram: bytes = b\"\"\nif program_start:\nprogram += random_bytes(program_start)\nif bloat:\nprogram += b\"\\x00\" * bloat\nif program_end:\nprogram += random_bytes(program_end)\nf.write(program)\n</code></pre>"},{"location":"Reference/#defensive_file_scannerscan","title":"defensive_file_scanner.scan","text":""},{"location":"Reference/#defensive_file_scanner.scan.Malware","title":"<code>Malware</code>","text":"<p>Malware Object</p> Source code in <code>defensive_file_scanner/scan.py</code> <pre><code>class Malware:\n\"\"\"\n    Malware Object\n    \"\"\"\ndef __init__(self, file: PurePath | str):\n\"\"\"\n        Initialise a suspected Malware Object.\n        Args:\n            file (PurePath | str): Path of the file to scan.\n        \"\"\"\nself.file: PurePath = Path(file)\nself.counter: Counter = Counter()\nlogger.info(f\"Initiating Scan of file: {file}\")\nlogger.debug(repr(self))\ndef __str__(self):\nreturn f\"file='{self.file}'\"\ndef __repr__(self):\nreturn f\"{type(self).__name__}({str(self)})\"\ndef test_whole_file(self) -&gt; list[tuple[str, int]]:\n\"\"\"\n        Scans the whole file and counts the hexbits.\n        Returns:\n            The count of the hex in the byte code ordered from most\n            to least common.\n        Todo:\n            - [ ] Add tqdm loading bar.\n        \"\"\"\nwith open(self.file, \"rb\", buffering=1024) as f:\nwhile True:\nif not (line := f.read(100)):\nbreak\nself.counter.update(line)\nlogger.success(f\"Most common bit: {self.counter.most_common(1)[0]}\")\nreturn self.counter.most_common()\n@property\ndef most_common(self) -&gt; tuple[str, int]:\n\"\"\"\n        The most come hex bit and frequency.\n        \"\"\"\nif self.counter:\nreturn self.counter.most_common(1)[0]\nreturn self.test_whole_file()[0]\n@property\ndef total_bits(self) -&gt; int:\n\"\"\"\n        The total number if hex bits.\n        \"\"\"\nreturn self.counter.total()\n@property\ndef ratio(self):\n\"\"\"\n        Ratio between most common count and total count.\n        \"\"\"\nreturn self.most_common[1] / self.total_bits\n@property\ndef file_hash(self) -&gt; str:\nraise NotImplementedError\ndef sum_of_bit(self) -&gt; int:\nraise NotImplementedError\n</code></pre>"},{"location":"Reference/#defensive_file_scanner.scan.Malware.most_common","title":"<code>most_common: tuple[str, int]</code>  <code>property</code>","text":"<p>The most come hex bit and frequency.</p>"},{"location":"Reference/#defensive_file_scanner.scan.Malware.ratio","title":"<code>ratio</code>  <code>property</code>","text":"<p>Ratio between most common count and total count.</p>"},{"location":"Reference/#defensive_file_scanner.scan.Malware.total_bits","title":"<code>total_bits: int</code>  <code>property</code>","text":"<p>The total number if hex bits.</p>"},{"location":"Reference/#defensive_file_scanner.scan.Malware.__init__","title":"<code>__init__(file)</code>","text":"<p>Initialise a suspected Malware Object.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>PurePath | str</code> <p>Path of the file to scan.</p> required Source code in <code>defensive_file_scanner/scan.py</code> <pre><code>def __init__(self, file: PurePath | str):\n\"\"\"\n    Initialise a suspected Malware Object.\n    Args:\n        file (PurePath | str): Path of the file to scan.\n    \"\"\"\nself.file: PurePath = Path(file)\nself.counter: Counter = Counter()\nlogger.info(f\"Initiating Scan of file: {file}\")\nlogger.debug(repr(self))\n</code></pre>"},{"location":"Reference/#defensive_file_scanner.scan.Malware.test_whole_file","title":"<code>test_whole_file()</code>","text":"<p>Scans the whole file and counts the hexbits.</p> <p>Returns:</p> Type Description <code>list[tuple[str, int]]</code> <p>The count of the hex in the byte code ordered from most</p> <code>list[tuple[str, int]]</code> <p>to least common.</p> Todo <ul> <li> Add tqdm loading bar.</li> </ul> Source code in <code>defensive_file_scanner/scan.py</code> <pre><code>def test_whole_file(self) -&gt; list[tuple[str, int]]:\n\"\"\"\n    Scans the whole file and counts the hexbits.\n    Returns:\n        The count of the hex in the byte code ordered from most\n        to least common.\n    Todo:\n        - [ ] Add tqdm loading bar.\n    \"\"\"\nwith open(self.file, \"rb\", buffering=1024) as f:\nwhile True:\nif not (line := f.read(100)):\nbreak\nself.counter.update(line)\nlogger.success(f\"Most common bit: {self.counter.most_common(1)[0]}\")\nreturn self.counter.most_common()\n</code></pre>"},{"location":"the_readme/","title":"Defensive File Scanner","text":""},{"location":"the_readme/#documentation","title":"Documentation","text":"<ul> <li>Current Main: GitHub Pages</li> <li>All Versions: Read the Docs</li> </ul>"}]}